package bot // import "cirello.io/gochatbot/bot"

import (
	"log"
	"sync"

	"cirello.io/gochatbot/brain"
	"cirello.io/gochatbot/messages"
)

// Self encapsulates all the necessary state to have a robot running. Including
// identity (Name).
type Self struct {
	name        string
	providerIn  chan messages.Message
	providerOut chan messages.Message
	rules       []RuleParser

	brain brain.Memorizer
}

var processOnce sync.Once // protects Process

// Option type is the self-referencing method of tweaking gobot's internals.
type Option func(*Self)

// New creates a new gobot.
func New(name string, opts ...Option) *Self {
	s := &Self{
		name:        name,
		brain:       brain.Brain(),
		providerIn:  make(chan messages.Message),
		providerOut: make(chan messages.Message),
	}
	log.Println("bot: applying options")
	for _, opt := range opts {
		opt(s)
	}
	return s
}

// Process connects the flow of incoming messages with the ruleset, and
// dispatches the outgoing messages generated by the ruleset. Each message lives
// in its own goroutine.
func (s *Self) Process() {
	processOnce.Do(func() {
		log.Println("bot: starting main loop")
		for in := range s.providerIn {
			go func(self Self, msg messages.Message) {
				for _, rule := range s.rules {
					responses := rule.ParseMessage(self, msg)
					for _, r := range responses {
						s.providerOut <- r
					}
				}
			}(*s, in)
		}
	})
}

// MemoryRead reads an arbitraty value from the robot's Brain.
func (s *Self) MemoryRead(namespace, key string) interface{} {
	return s.brain.Read(namespace, key)
}

// MemorySave reads an arbitraty value from the robot's Brain.
func (s *Self) MemorySave(namespace, key string, value interface{}) {
	s.brain.Save(namespace, key, value)
}

// Name returns robot's name - identity used for answering direct messages.
func (s *Self) Name() string {
	return s.name
}
